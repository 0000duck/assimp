//-------------------------------------------------------------------------------
/**
*	This program is distributed under the terms of the GNU Lesser General
*	Public License (LGPL). 
*
*	ASSIMP Viewer Utility
*
*/
//-------------------------------------------------------------------------------

#include "stdafx.h"
#include "assimp_view.h"


namespace AssimpView {

std::string g_szNormalsShader = std::string(
	//-------------------------------------------------------------------------------\n"
	/**\n"
	*	This program is distributed under the terms of the GNU Lesser General\n
	*	Public License (LGPL). \n
	*\n
	*	ASSIMP Viewer Utility\n
	*\n"
	*/
	//-------------------------------------------------------------------------------\n"


	// World * View * Projection matrix\n"
	// NOTE: Assume that the material uses a WorldViewProjection matrix\n"
	"float4x4 WorldViewProjection	: WORLDVIEWPROJECTION;\n"
	"float4 OUTPUT_COLOR;\n"
	

	// ----------------------------------------------------------------------------\n"
	// Vertex shader input structure\n"
	// ----------------------------------------------------------------------------\n"
	"struct VS_INPUT\n"
		"{\n"
		"// Position\n"
		"float3 Position : POSITION;\n"
		"};\n"


	// ----------------------------------------------------------------------------\n"
	// Vertex shader output structure\n"
	// ----------------------------------------------------------------------------\n"
	"struct VS_OUTPUT\n"
		"{\n"
		"// Position\n"
		"float4 Position : POSITION;\n"
		"};\n"

	// ----------------------------------------------------------------------------\n"
	// Vertex shader\n"
	// ----------------------------------------------------------------------------\n"
	"VS_OUTPUT RenderNormalsVS(VS_INPUT IN)\n"
		"{\n"
		"// Initialize the output structure with zero\n"
		"VS_OUTPUT Out = (VS_OUTPUT)0;\n"

		"// Multiply with the WorldViewProjection matrix\n"
		"Out.Position = mul(float4(IN.Position,1.0f),WorldViewProjection);\n"

		"return Out;\n"
		"}\n"


	// ----------------------------------------------------------------------------\n"
	// Pixel shader\n"
	// ----------------------------------------------------------------------------\n"
	"float4 RenderNormalsPS() : COLOR\n"
		"{\n"
		"return OUTPUT_COLOR;\n"
		"}\n"


	// ----------------------------------------------------------------------------\n"
	// Technique for the normal rendering effect (ps_2_0)\n"
	// ----------------------------------------------------------------------------\n"
	"technique RenderNormals\n"
		"{\n"
		"pass p0\n"
		"{\n"
		"CullMode=none;\n"
		"PixelShader = compile ps_2_0 RenderNormalsPS();\n"
		"VertexShader = compile vs_2_0 RenderNormalsVS();\n"
		"}\n"
		"};\n"
	);

std::string g_szSkyboxShader = std::string(
	//-------------------------------------------------------------------------------\n"
	/**\n"
	*	This program is distributed under the terms of the GNU Lesser General\n
	*	Public License (LGPL). \n
	*\n
	*	ASSIMP Viewer Utility\n
	*\n"
	*/
	//-------------------------------------------------------------------------------\n"


	// ----------------------------------------------------------------------------\n"
	// Sampler and texture for the skybox\n"
	// ----------------------------------------------------------------------------\n"
	"textureCUBE lw_tex_envmap;\n"
	"samplerCUBE EnvironmentMapSampler = sampler_state\n"
	"{\n"
	"Texture = (lw_tex_envmap);\n"
	"AddressU = CLAMP;\n"
	"AddressV = CLAMP;\n"
	"AddressW = CLAMP;\n"

	"MAGFILTER = linear;\n"
	"MINFILTER = linear;\n"
	"};\n"

	// World * View * Projection matrix\n"
	// NOTE: Assume that the material uses a WorldViewProjection matrix\n"
	"float4x4 WorldViewProjection	: WORLDVIEWPROJECTION;\n"
	

	// ----------------------------------------------------------------------------\n"
	// Vertex shader input structure\n"
	// ----------------------------------------------------------------------------\n"
	"struct VS_INPUT\n"
		"{\n"
		// Position\n"
		"float3 Position : POSITION;\n"

		// 3D-Texture coordinate\n"
		"float3 Texture0 : TEXCOORD0;\n"
		"};\n"


	// ----------------------------------------------------------------------------\n"
	// Vertex shader output structure\n"
	// ----------------------------------------------------------------------------\n"
	"struct VS_OUTPUT\n"
		"{\n"
		// Position\n"
		"float4 Position : POSITION;\n"

		// 3D-Texture coordinate\n"
		"float3 Texture0 : TEXCOORD0;\n"
		"};\n"

	// ----------------------------------------------------------------------------\n"
	// Vertex shader\n"
	// ----------------------------------------------------------------------------\n"
	"VS_OUTPUT RenderSkyBoxVS(VS_INPUT IN)\n"
		"{\n"
		// Initialize the output structure with zero\n"
		"VS_OUTPUT Out = (VS_OUTPUT)0;\n"

		// Multiply with the WorldViewProjection matrix\n"
		"Out.Position = mul(float4(IN.Position,1.0f),WorldViewProjection);\n"

		// Set z to w to ensure z becomes 1.0 after the division through\n"
		// w occurs\n"
		"Out.Position.z = Out.Position.w;\n"
	
		// Simply pass through texture coordinates\n"
		"Out.Texture0 = IN.Texture0;\n"

		"return Out;\n"
		"}\n"


	// ----------------------------------------------------------------------------\n"
	// Pixel shader\n"
	// ----------------------------------------------------------------------------\n"
	"float4 RenderSkyBoxPS(float3 Texture0 : TEXCOORD0) : COLOR\n"
		"{\n"
		// Lookup the skybox texture\n"
		"return texCUBE(EnvironmentMapSampler,Texture0) ;\n"
		"}\n"


	// ----------------------------------------------------------------------------\n"
	// Technique for the skybox shader (ps_2_0)\n"
	// ----------------------------------------------------------------------------\n"
	"technique RenderSkyBox\n"
		"{\n"
		"pass p0\n"
		"{\n"
		"ZWriteEnable = FALSE;\n"
		"FogEnable = FALSE;\n"
		"CullMode = NONE;\n"

		"PixelShader = compile ps_2_0 RenderSkyBoxPS();\n"
		"VertexShader = compile vs_2_0 RenderSkyBoxVS();\n"
		"}\n"
		"};\n"

	"texture TEXTURE_2D;\n"
		"sampler TEXTURE_SAMPLER = sampler_state\n"
			"{\n"
			"Texture = (TEXTURE_2D);\n"
			"};\n"


	// ----------------------------------------------------------------------------\n"
	"struct VS_OUTPUT2\n"
		"{\n"
		"// Position\n"
		"float4 _Position : POSITION;\n"

		"// Texture coordinate\n"
		"float2 _TexCoord0 : TEXCOORD0;\n"
		"};\n"


	// ----------------------------------------------------------------------------\n"
	"VS_OUTPUT2 RenderImageVS(float4 INPosition : POSITION,\n"
		"float2 INTexCoord0 : TEXCOORD0 )\n"
		"{\n"
		// Initialize the output structure with zero\n"
		"VS_OUTPUT2 Out = (VS_OUTPUT2)0;\n"

		"Out._Position.xy = INPosition.xy;\n"
		"Out._Position.z = Out._Position.w = 1.0f;\n"

		"Out._TexCoord0 = INTexCoord0;\n"

		"return Out;\n"
		"}\n"

	// ----------------------------------------------------------------------------\n"
	"float4 RenderImagePS(float2 IN : TEXCOORD0) : COLOR\n"
		"{\n"
		"return tex2D(TEXTURE_SAMPLER,IN);\n"
		"}\n"


	// ----------------------------------------------------------------------------\n"
	// Technique for the background image shader (ps_2_0)\n"
	// ----------------------------------------------------------------------------\n"
	"technique RenderImage2D\n"
		"{\n"
		"pass p0\n"
			"{\n"
			"ZWriteEnable = FALSE;\n"
			"FogEnable = FALSE;\n"
			"CullMode = NONE;\n"
	
			"PixelShader = compile ps_2_0 RenderImagePS();\n"
			"VertexShader = compile vs_2_0 RenderImageVS();\n"
			"}\n"
		"};\n"
		);

std::string g_szDefaultShader = std::string(
	//-------------------------------------------------------------------------------\n"
	/**\n"
	*	This program is distributed under the terms of the GNU Lesser General\n
	*	Public License (LGPL). \n
	*\n
	*	ASSIMP Viewer Utility\n
	*\n"
	*/
	//-------------------------------------------------------------------------------\n"


	// World * View * Projection matrix\n"
	// NOTE: Assume that the material uses a WorldViewProjection matrix\n"
	"float4x4 WorldViewProjection	: WORLDVIEWPROJECTION;\n"
	"float4x4 World					: WORLD;\n"
	"float4x3 WorldInverseTranspose	: WORLDINVERSETRANSPOSE;\n"


	// light colors\n"
	"float3 afLightColor[5];\n"

	// light direction \n"
	"float3 afLightDir[5];\n"

	// position of the camera in worldspace\n"
	"float3 vCameraPos : CAMERAPOSITION;\n"


	// ----------------------------------------------------------------------------\n"
	// Vertex shader input structure\n"
	// ----------------------------------------------------------------------------\n"
	"struct VS_INPUT\n"
		"{\n"
		"// Position\n"
		"float3 Position : POSITION;\n"
		"float3 Normal : NORMAL;\n"
		"};\n"


	// ----------------------------------------------------------------------------\n"
	// Vertex shader output structure\n"
	// ----------------------------------------------------------------------------\n"
	"struct VS_OUTPUT\n"
		"{\n"
		// Position\n"
		"float4 Position : POSITION;\n"

		"float3 ViewDir : TEXCOORD0;\n"
		"float3 Normal : TEXCOORD1;\n"
		"};\n"

	// ----------------------------------------------------------------------------\n"
	// Vertex shader\n"
	// ----------------------------------------------------------------------------\n"
	"VS_OUTPUT DefaultVShader(VS_INPUT IN)\n"
		"{\n"
		// Initialize the output structure with zero\n"
		"VS_OUTPUT Out = (VS_OUTPUT)0;\n"

		// Multiply with the WorldViewProjection matrix\n"
		"Out.Position = mul(float4(IN.Position,1.0f),WorldViewProjection);\n"
		"float3 WorldPos = mul(float4(IN.Position,1.0f),World);\n"
		"Out.ViewDir = vCameraPos - WorldPos;\n"
		"Out.Normal = mul(IN.Normal,WorldInverseTranspose);\n"

		"return Out;\n"
		"}\n"


	// ----------------------------------------------------------------------------\n"
	// Pixel shader\n"
	// ----------------------------------------------------------------------------\n"
	"float4 DefaultPShaderSpecular_D1(VS_OUTPUT IN) : COLOR\n"
		"{\n"
		"float4 OUT = float4(0.0f,0.0f,0.0f,1.0f);\n"

		"float3 Normal = normalize(IN.Normal);\n"
		"float3 ViewDir = normalize(IN.ViewDir);\n"

		"{\n"
			"float L1 = dot(Normal,afLightDir[0]) * 0.5f + 0.5f;\n"
			"float3 Reflect = reflect (Normal,afLightDir[0]);\n"
			"float fHalfLambert = L1*L1;\n"
			"OUT.rgb += afLightColor[0] * (fHalfLambert +\n"
				"saturate(fHalfLambert * 4.0f) * pow(dot(Reflect,ViewDir),9));\n"
		"}\n"
		"return OUT;\n"
		"}\n"
	// ----------------------------------------------------------------------------\n"
		"float4 DefaultPShaderSpecular_D2(VS_OUTPUT IN) : COLOR\n"
		"{\n"
		"float4 OUT = float4(0.0f,0.0f,0.0f,1.0f);\n"

		"float3 Normal = normalize(IN.Normal);\n"
		"float3 ViewDir = normalize(IN.ViewDir);\n"

		"{\n"
			"float L1 = dot(Normal,afLightDir[0]) * 0.5f + 0.5f;\n"
			"float3 Reflect = reflect (ViewDir,Normal);\n"
			"float fHalfLambert = L1*L1;\n"
			"OUT.rgb += afLightColor[0] * (fHalfLambert +\n"
			"saturate(fHalfLambert * 4.0f) * pow(dot(Reflect,afLightDir[0]),9));\n"
		"}\n"
		"{\n"
			"float L1 = dot(Normal,afLightDir[1]) * 0.5f + 0.5f;\n"
			"float3 Reflect = reflect (ViewDir,Normal);\n"
			"float fHalfLambert = L1*L1;\n"
			"OUT.rgb += afLightColor[1] * (fHalfLambert +\n"
			"saturate(fHalfLambert * 4.0f) * pow(dot(Reflect,afLightDir[1]),9));\n"
		"}\n"
		"return OUT;\n"
		"}\n"
	// ----------------------------------------------------------------------------\n"
	"float4 DefaultPShaderSpecular_PS20_D1(VS_OUTPUT IN) : COLOR\n"
		"{\n"
		"float4 OUT = float4(0.0f,0.0f,0.0f,1.0f);\n"

		"float3 Normal = normalize(IN.Normal);\n"
		"float3 ViewDir = normalize(IN.ViewDir);\n"

		"{\n"
			"float L1 = dot(Normal,afLightDir[0]);\n"
			"float3 Reflect = reflect (Normal,afLightDir[0]);\n"
			"OUT.rgb += afLightColor[0] * ((L1) +\n"
			"pow(dot(Reflect,ViewDir),9));\n"
		"}\n"

		"return OUT;\n"
		"}\n"
	// ----------------------------------------------------------------------------\n"
	"float4 DefaultPShaderSpecular_PS20_D2(VS_OUTPUT IN) : COLOR\n"
		"{\n"
		"float4 OUT = float4(0.0f,0.0f,0.0f,1.0f);\n"

		"float3 Normal = normalize(IN.Normal);\n"
		"float3 ViewDir = normalize(IN.ViewDir);\n"

		"{\n"
			"float L1 = dot(Normal,afLightDir[0]);\n"
			"float3 Reflect = reflect (Normal,afLightDir[0]);\n"
			"OUT.rgb += afLightColor[0] * ((L1) +\n"
			"pow(dot(Reflect,ViewDir),9));\n"
		"}\n"
		"{\n"
			"float L1 = dot(Normal,afLightDir[1]);\n"
			"float3 Reflect = reflect (Normal,afLightDir[1]);\n"
			"OUT.rgb += afLightColor[1] * ((L1) +\n"
			"pow(dot(Reflect,ViewDir),9));\n"
		"}\n"
		"return OUT;\n"
		"}\n"


	// ----------------------------------------------------------------------------\n"
	// Technique for the default effect\n"
	// ----------------------------------------------------------------------------\n"
	"technique DefaultFXSpecular_D1\n"
		"{\n"
		"pass p0\n"
			"{\n"
			"CullMode=none;\n"
			"PixelShader = compile ps_3_0 DefaultPShaderSpecular_D1();\n"
			"VertexShader = compile vs_3_0 DefaultVShader();\n"
			"}\n"
		"};\n"
	"technique DefaultFXSpecular_D2\n"
		"{\n"
		"pass p0\n"
			"{\n"
			"CullMode=none;\n"
			"PixelShader = compile ps_3_0 DefaultPShaderSpecular_D2();\n"
			"VertexShader = compile vs_3_0 DefaultVShader();\n"
			"}\n"
		"};\n"


	// ----------------------------------------------------------------------------\n"
	// Technique for the default effect (ps_2_0)\n"
	// ----------------------------------------------------------------------------\n"
	"technique DefaultFXSpecular_PS20_D1\n"
		"{\n"
		"pass p0\n"
		"{\n"
		"CullMode=none;\n"
		"PixelShader = compile ps_2_0 DefaultPShaderSpecular_PS20_D1();\n"
		"VertexShader = compile vs_2_0 DefaultVShader();\n"
		"}\n"
		"};\n"
	"technique DefaultFXSpecular_PS20_D2\n"
		"{\n"
		"pass p0\n"
		"{\n"
		"CullMode=none;\n"
		"PixelShader = compile ps_2_0 DefaultPShaderSpecular_PS20_D2();\n"
		"VertexShader = compile vs_2_0 DefaultVShader();\n"
		"}\n"
		"};\n"
		);


std::string g_szMaterialShader = std::string(
	//-------------------------------------------------------------------------------\n"
	/**\n"
	*	This program is distributed under the terms of the GNU Lesser General\n
	*	Public License (LGPL). \n
	*\n
	*	ASSIMP Viewer Utility\n
	*\n"
	*/
	//-------------------------------------------------------------------------------\n"


	// World * View * Projection matrix\n"
	// NOTE: Assume that the material uses a WorldViewProjection matrix\n"
	"float4x4 WorldViewProjection	: WORLDVIEWPROJECTION;\n"
	"float4x4 World					: WORLD;\n"
	"float4x3 WorldInverseTranspose	: WORLDINVERSETRANSPOSE;\n"

	"#ifndef AV_DISABLESSS\n"
	"float4x3 ViewProj;\n"
	"float4x3 InvViewProj;\n"
	"#endif\n"

	// light colors (diffuse and specular)\n"
	"float4 afLightColor[5];\n"
	"float4 afLightColorAmbient[5];\n"

	// light direction \n"
	"float3 afLightDir[5];\n"

	// position of the camera in worldspace\n"
	"float3 vCameraPos : CAMERAPOSITION;\n"

	"#ifdef AV_DIFFUSE_TEXTURE\n"
		"texture DIFFUSE_TEXTURE;\n"
		"sampler DIFFUSE_SAMPLER\n"
		"{\n"
		"Texture = <DIFFUSE_TEXTURE>;\n"
		"MinFilter=LINEAR;\n"
		"MagFilter=LINEAR;\n"
		"MipFilter=LINEAR;\n"
		"};\n"
	"#endif // AV_DIFFUSE_TEXTUR\n"

	"#ifdef AV_SPECULAR_TEXTURE\n"
		"texture SPECULAR_TEXTURE;\n"
		"sampler SPECULAR_SAMPLER\n"
		"{\n"
		"Texture = <SPECULAR_TEXTURE>;\n"
		"MinFilter=LINEAR;\n"
		"MagFilter=LINEAR;\n"
		"MipFilter=LINEAR;\n"
		"};\n"
	"#endif // AV_SPECULAR_TEXTUR\n"

	"#ifdef AV_AMBIENT_TEXTURE\n"
		"texture AMBIENT_TEXTURE;\n"
		"sampler AMBIENT_SAMPLER\n"
		"{\n"
		"Texture = <AMBIENT_TEXTURE>;\n"
		"MinFilter=LINEAR;\n"
		"MagFilter=LINEAR;\n"
		"MipFilter=LINEAR;\n"
		"};\n"
	"#endif // AV_AMBIENT_TEXTUR\n"

	"#ifdef AV_OPACITY_TEXTURE\n"
		"texture OPACITY_TEXTURE;\n"
		"sampler OPACITY_SAMPLER\n"
		"{\n"
		"Texture = <OPACITY_TEXTURE>;\n"
		"MinFilter=LINEAR;\n"
		"MagFilter=LINEAR;\n"
		"MipFilter=LINEAR;\n"
		"};\n"
	"#endif // AV_OPACITY_TEXTURE\n"

	"#ifdef AV_EMISSIVE_TEXTURE\n"
		"texture EMISSIVE_TEXTURE;\n"
		"sampler EMISSIVE_SAMPLER\n"
		"{\n"
		"Texture = <EMISSIVE_TEXTURE>;\n"
		"MinFilter=LINEAR;\n"
		"MagFilter=LINEAR;\n"
		"MipFilter=LINEAR;\n"
		"};\n"
	"#endif // AV_EMISSIVE_TEXTUR\n"

	"#ifdef AV_NORMAL_TEXTURE\n"
		"texture NORMAL_TEXTURE;\n"
		"sampler NORMAL_SAMPLER\n"
		"{\n"
		"Texture = <NORMAL_TEXTURE>;\n"
		"MinFilter=LINEAR;\n"
		"MagFilter=LINEAR;\n"
		"MipFilter=LINEAR;\n"
		"};\n"
	"#endif // AV_NORMAL_TEXTURE\n"

	"#ifdef AV_SKYBOX_LOOKUP\n"
		"textureCUBE lw_tex_envmap;\n"
		"samplerCUBE EnvironmentMapSampler = sampler_state\n"
		"{\n"
		"Texture = (lw_tex_envmap);\n"
		"AddressU = CLAMP;\n"
		"AddressV = CLAMP;\n"
		"AddressW = CLAMP;\n"

		"MAGFILTER = linear;\n"
		"MINFILTER = linear;\n"
		"};\n"
	"#endif // AV_SKYBOX_LOOKUP\n"

	"float4 DIFFUSE_COLOR;\n"
	"float4 SPECULAR_COLOR;\n"
	"float4 AMBIENT_COLOR;\n"
	"float4 EMISSIVE_COLOR;\n"

	"#ifdef AV_SPECULAR_COMPONENT\n"
	"float SPECULARITY;\n"
	"#endif\n"
	"#ifdef AV_OPACITY\n"
	"float TRANSPARENCY;\n"
	"#endif\n"

	// ----------------------------------------------------------------------------\n"
	// Vertex shader input structure\n"
	// ----------------------------------------------------------------------------\n"
	"struct VS_INPUT\n"
		"{\n"
		// Position\n"
		"float3 Position : POSITION;\n"
		"float3 Normal : NORMAL;\n"

		// NOTE: Tangents and bitangents are passed to the shader
		// in every case, even if not required. This saves a few lines 
		// of code ...

		"float3 Tangent   : TEXCOORD0;\n"
		"float3 Bitangent : TEXCOORD1;\n"
		"float2 TexCoord0 : TEXCOORD2;\n"
		"};\n"


	// ----------------------------------------------------------------------------\n"
	// Vertex shader output structure\n"
	// ----------------------------------------------------------------------------\n"
	"struct VS_OUTPUT\n"
		"{\n"
		// Position\n"
		"float4 Position : POSITION;\n"

		"float3 ViewDir : TEXCOORD0;\n"

		"#ifndef AV_NORMAL_TEXTURE\n"
		"float3 Normal  : TEXCOORD1;\n"
		"#endif\n"

		"float2 TexCoord0 : TEXCOORD2;\n"

		"#ifdef AV_NORMAL_TEXTURE\n"

		"float3 Light0 : TEXCOORD3;\n"
		"float3 Light1 : TEXCOORD4;\n"

		"#endif\n"
		"};\n"


	// ----------------------------------------------------------------------------\n"
	// Selective SuperSampling in screenspace for reflection lookups\n"
	// ----------------------------------------------------------------------------\n"
	"#ifndef AV_SKYBOX_LOOKUP\n"
	"#define AV_DISABLESSS\n"
	"#endif\n"
	"#ifndef AV_DISABLESSS\n"
	"float3 GetSSSCubeMap(float3 Reflect)\n"
		"{\n"
		// compute the reflection vector in screen space\n"
		"float3 ScreenReflect = mul(Reflect,ViewProj);\n"

		// compute the gradients of the reflection vector\n"
		"float3 fDX = ddx(ScreenReflect);\n"
		"float3 fDY = ddy(ScreenReflect);\n"

		// take the center step and calculate gradients for it\n"
		"float3 fColor = texCUBE(EnvironmentMapSampler,Reflect).rgb;\n"

		// Take 10 samples around the center step \n"
		"fColor += texCUBEgrad(EnvironmentMapSampler,mul( ScreenReflect + (0.4f * 2.0 / 3.5) * fDX + (0.4f * 2.0 / 3.5) * fDY, InvViewProj),fDX,fDY).rgb;\n"
		"fColor += texCUBEgrad(EnvironmentMapSampler,mul( ScreenReflect + (0.4f * 3.0 / 3.5) * fDX + (0.4f *-1.0 / 3.5) * fDY, InvViewProj),fDX,fDY).rgb;\n"
		"fColor += texCUBEgrad(EnvironmentMapSampler,mul( ScreenReflect + (0.4f * 1.0 / 3.5) * fDX + (0.4f *-3.0 / 3.5) * fDY, InvViewProj),fDX,fDY).rgb;\n"
		"fColor += texCUBEgrad(EnvironmentMapSampler,mul( ScreenReflect + (0.4f *-2.0 / 3.5) * fDX + (0.4f *-2.0 / 3.5) * fDY, InvViewProj),fDX,fDY).rgb;\n"
		"fColor += texCUBEgrad(EnvironmentMapSampler,mul( ScreenReflect + (0.4f *-3.0 / 3.5) * fDX + (0.4f * 1.0 / 3.5) * fDY, InvViewProj),fDX,fDY).rgb;\n"
		"fColor += texCUBEgrad(EnvironmentMapSampler,mul( ScreenReflect + (0.4f *-1.0 / 3.5) * fDX + (0.4f * 3.0 / 3.5) * fDY, InvViewProj),fDX,fDY).rgb;\n"
		"fColor /= 7;\n"
		"return fColor;\n"
		"}\n"
	"#else\n"
		"#define GetSSSCubeMap(_refl) (texCUBElod(EnvironmentMapSampler,float4(_refl,0.0f)).rgb) \n"
	"#endif\n"

	// bugfix: if normal mapping is active we have the reflection
	// vector in tangent, not in world space. Would need the inverse
	// of the TSM matrix in the pixel shader (or world space tangent mapping)
	// Simply disable realtime reflection for normal mapping.
	"#ifdef AV_NORMAL_TEXTURE\n"
	"#undef GetSSSCubeMap\n"
	"#define GetSSSCubeMap(_refl) (float3(1.0f,1.0f,1.0f))\n"
	"#endif\n"


	// ----------------------------------------------------------------------------\n"
	// Vertex shader\n"
	// ----------------------------------------------------------------------------\n"
	"VS_OUTPUT MaterialVShader_D1(VS_INPUT IN)\n"
		"{\n"
		// Initialize the output structure with zero\n"
		"VS_OUTPUT Out = (VS_OUTPUT)0;\n"

		// Multiply with the WorldViewProjection matrix\n"
		"Out.Position = mul(float4(IN.Position,1.0f),WorldViewProjection);\n"
		"float3 WorldPos = mul(float4(IN.Position,1.0f),World);\n"
		"Out.TexCoord0 = IN.TexCoord0;\n"

		"#ifndef AV_NORMAL_TEXTURE\n"
		"Out.ViewDir = vCameraPos - WorldPos;\n"
		"Out.Normal = mul(IN.Normal,WorldInverseTranspose);\n"
		"#endif\n"
		
		"#ifdef AV_NORMAL_TEXTURE\n"
		"float3x3 TBNMatrix = float3x3(IN.Tangent, IN.Bitangent, IN.Normal);\n"
		"float3x3 WTTS      = mul(TBNMatrix, (float3x3)WorldInverseTranspose);\n"
		"Out.Light0         = normalize(mul(WTTS, afLightDir[0] ));\n"
		"Out.ViewDir = normalize(mul(WTTS, (vCameraPos - WorldPos)));\n"
		"#endif\n"
		"return Out;\n"
		"}\n"
	"// ----------------------------------------------------------------------------\n"
	"VS_OUTPUT MaterialVShader_D2(VS_INPUT IN)\n"
		"{\n"
		// Initialize the output structure with zero\n"
		"VS_OUTPUT Out = (VS_OUTPUT)0;\n"

		// Multiply with the WorldViewProjection matrix\n"
		"Out.Position = mul(float4(IN.Position,1.0f),WorldViewProjection);\n"
		"float3 WorldPos = mul(float4(IN.Position,1.0f),World);\n"
		"Out.TexCoord0 = IN.TexCoord0;\n"

		"#ifndef AV_NORMAL_TEXTURE\n"
		"Out.ViewDir = vCameraPos - WorldPos;\n"
		"Out.Normal = mul(IN.Normal,WorldInverseTranspose);\n"
		"#endif\n"

		"#ifdef AV_NORMAL_TEXTURE\n"
		"float3x3 TBNMatrix = float3x3(IN.Tangent, IN.Bitangent, IN.Normal);\n"
		"float3x3 WTTS      = mul(TBNMatrix, (float3x3)WorldInverseTranspose);\n"
		"Out.Light0         = normalize(mul(WTTS, afLightDir[0] ));\n"
		"Out.Light1         = normalize(mul(WTTS, afLightDir[1] ));\n"
		"Out.ViewDir = normalize(mul(WTTS, (vCameraPos - WorldPos)));\n"
		"#endif\n"
		"return Out;\n"
		"}\n"


	// ----------------------------------------------------------------------------\n"
	// Pixel shader\n"
	// ----------------------------------------------------------------------------\n"
	"float4 MaterialPShaderSpecular_D1(VS_OUTPUT IN) : COLOR\n"
		"{\n"
		"float4 OUT = float4(0.0f,0.0f,0.0f,1.0f);\n"

		"#ifdef AV_NORMAL_TEXTURE\n"
		"float3 IN_Light0 = normalize(IN.Light0);\n"
		"float3 Normal  =  normalize(2.0f * tex2D(NORMAL_SAMPLER, IN.TexCoord0).rgb - 1.0f);\n"
		"#else\n"
		"float3 Normal = normalize(IN.Normal);\n"
		"#endif \n"
		"float3 ViewDir = normalize(IN.ViewDir);\n"
		"#ifdef AV_SPECULAR_COMPONENT\n"
			"float3 Reflect = -normalize(reflect (ViewDir,Normal));\n"
		"#endif // !AV_SPECULAR_COMPONENT\n"

		"{\n"
		"#ifdef AV_NORMAL_TEXTURE\n"
			"float L1 =  dot(Normal,IN_Light0) * 0.5f + 0.5f;\n"
			"#define AV_LIGHT_0 IN_Light0\n"
			// would need to convert the reflection vector into world space ....
			// simply let it ...
		"#else\n"
			"float L1 = dot(Normal,afLightDir[0]) * 0.5f + 0.5f;\n"
			"#define AV_LIGHT_0 afLightDir[0]\n"
		"#endif\n"
			"float fHalfLambert = L1*L1;\n"
		"#ifdef AV_DIFFUSE_TEXTURE\n"
			"OUT.rgb += afLightColor[0].rgb * DIFFUSE_COLOR.rgb * tex2D(DIFFUSE_SAMPLER,IN.TexCoord0).rgb * fHalfLambert +\n"
		"#else\n"
			"OUT.rgb += afLightColor[0].rgb * DIFFUSE_COLOR.rgb * fHalfLambert +\n"
		"#endif // !AV_DIFFUSE_TEXTURE\n"

		"#ifdef AV_SPECULAR_COMPONENT\n"
			"#ifndef AV_SKYBOX_LOOKUP\n"
				"#ifdef AV_SPECULAR_TEXTURE\n"
					"SPECULAR_COLOR.rgb * afLightColor[0].rgb * tex2D(SPECULAR_SAMPLER,IN.TexCoord0).rgb * (saturate(fHalfLambert * 4.0f) * pow(dot(Reflect,AV_LIGHT_0),SPECULARITY)) + \n"
				"#else\n"
					"SPECULAR_COLOR.rgb * afLightColor[0].rgb * (saturate(fHalfLambert * 4.0f) * pow(dot(Reflect,AV_LIGHT_0),SPECULARITY)) + \n"
				"#endif // !AV_SPECULAR_TEXTURE\n"
			"#else\n"
				"#ifdef AV_SPECULAR_TEXTURE\n"
					"SPECULAR_COLOR.rgb * afLightColor[0].rgb * GetSSSCubeMap(Reflect) * tex2D(SPECULAR_SAMPLER,IN.TexCoord0).rgb * (saturate(fHalfLambert * 4.0f) * pow(dot(Reflect,AV_LIGHT_0),SPECULARITY)) + \n"
				"#else\n"
					"SPECULAR_COLOR.rgb * afLightColor[0].rgb * GetSSSCubeMap(Reflect) * (saturate(fHalfLambert * 4.0f) * pow(dot(Reflect,AV_LIGHT_0),SPECULARITY)) + \n"
				"#endif // !AV_SPECULAR_TEXTURE\n"
			"#endif // !AV_SKYBOX_LOOKUP\n"
		"#endif // !AV_SPECULAR_COMPONENT\n"

		"#ifdef AV_AMBIENT_TEXTURE\n"
			"AMBIENT_COLOR.rgb * afLightColorAmbient[0].rgb * tex2D(AMBIENT_SAMPLER,IN.TexCoord0).rgb +\n"
		"#else\n"
			"AMBIENT_COLOR.rgb * afLightColorAmbient[0].rgb + \n"
		"#endif // !AV_AMBIENT_TEXTURE\n"
     		"#ifdef AV_EMISSIVE_TEXTURE\n"
			"EMISSIVE_COLOR.rgb * tex2D(EMISSIVE_SAMPLER,IN.TexCoord0).rgb;\n"
		"#else \n"
			"EMISSIVE_COLOR.rgb;\n"
		"#endif // !AV_EMISSIVE_TEXTURE\n"
		"}\n"
		"#ifdef AV_OPACITY\n"
		"OUT.a = TRANSPARENCY;\n"
		"#endif\n"
		"#ifdef AV_OPACITY_TEXTURE\n"
		"OUT.a *= tex2D(OPACITY_SAMPLER,IN.TexCoord0). AV_OPACITY_TEXTURE_REGISTER_MASK;\n"
		"#endif\n"
		"return OUT;\n"

		"#undef AV_LIGHT_0\n"
		"}\n"
	// ----------------------------------------------------------------------------\n"
	"float4 MaterialPShaderSpecular_D2(VS_OUTPUT IN) : COLOR\n"
		"{\n"
		"float4 OUT = float4(0.0f,0.0f,0.0f,1.0f);\n"

		"#ifdef AV_NORMAL_TEXTURE\n"
		"float3 IN_Light0 = normalize(IN.Light0);\n"
		"float3 IN_Light1 = normalize(IN.Light1);\n"
		"float3 Normal  =  normalize(2.0f * tex2D(NORMAL_SAMPLER, IN.TexCoord0).rgb - 1.0f);\n"
		"#else\n"
		"float3 Normal = normalize(IN.Normal);\n"
		"#endif \n"
		"float3 ViewDir = normalize(IN.ViewDir);\n"
		"#ifdef AV_SPECULAR_COMPONENT\n"
			"float3 Reflect = -normalize(reflect (ViewDir,Normal));\n"
		"#endif // !AV_SPECULAR_COMPONENT\n"

		"{\n"
		
		"#ifdef AV_NORMAL_TEXTURE\n"
			"float L1 = dot(Normal,IN_Light0) * 0.5f + 0.5f;\n"
			"#define AV_LIGHT_0 IN_Light0\n"
		"#else\n"
			"float L1 = dot(Normal,afLightDir[0]) * 0.5f + 0.5f;\n"
			"#define AV_LIGHT_0 afLightDir[0]\n"
		"#endif\n"
			"float fHalfLambert = L1*L1;\n"
			
		"#ifdef AV_DIFFUSE_TEXTURE\n"
			"OUT.rgb += afLightColor[0].rgb * DIFFUSE_COLOR.rgb * tex2D(DIFFUSE_SAMPLER,IN.TexCoord0).rgb * fHalfLambert +\n"
		"#else\n"
			"OUT.rgb += afLightColor[0].rgb * DIFFUSE_COLOR.rgb * fHalfLambert +\n"
		"#endif // !AV_DIFFUSE_TEXTURE\n"

		"#ifdef AV_SPECULAR_COMPONENT\n"
			"#ifndef AV_SKYBOX_LOOKUP\n"
				"#ifdef AV_SPECULAR_TEXTURE\n"
					"SPECULAR_COLOR.rgb * afLightColor[0].rgb * tex2D(SPECULAR_SAMPLER,IN.TexCoord0).rgb * (saturate(fHalfLambert * 4.0f) * pow(dot(Reflect,AV_LIGHT_0),SPECULARITY)) + \n"
				"#else\n"
					"SPECULAR_COLOR.rgb * afLightColor[0].rgb * (saturate(fHalfLambert * 4.0f) * pow(dot(Reflect,AV_LIGHT_0),SPECULARITY)) + \n"
				"#endif // !AV_SPECULAR_TEXTURE\n"
			"#else\n"
				"#ifdef AV_SPECULAR_TEXTURE\n"
					"SPECULAR_COLOR.rgb * afLightColor[0].rgb * GetSSSCubeMap(Reflect) * tex2D(SPECULAR_SAMPLER,IN.TexCoord0).rgb * (saturate(fHalfLambert * 4.0f) * pow(dot(Reflect,AV_LIGHT_0),SPECULARITY)) + \n"
				"#else\n"
					"SPECULAR_COLOR.rgb * afLightColor[0].rgb * GetSSSCubeMap(Reflect) * (saturate(fHalfLambert * 4.0f) * pow(dot(Reflect,AV_LIGHT_0),SPECULARITY)) + \n"
				"#endif // !AV_SPECULAR_TEXTURE\n"
			"#endif // !AV_SKYBOX_LOOKUP\n"
		"#endif // !AV_SPECULAR_COMPONENT\n"
		"#ifdef AV_AMBIENT_TEXTURE\n"
			"AMBIENT_COLOR.rgb * afLightColorAmbient[0].rgb * tex2D(AMBIENT_SAMPLER,IN.TexCoord0).rgb + \n"
		"#else\n"
			"AMBIENT_COLOR.rgb * afLightColorAmbient[0].rgb + \n"
		"#endif // !AV_AMBIENT_TEXTURE\n"
		"#ifdef AV_EMISSIVE_TEXTURE\n"
			"EMISSIVE_COLOR.rgb * tex2D(EMISSIVE_SAMPLER,IN.TexCoord0).rgb;\n"
		"#else \n"
			"EMISSIVE_COLOR.rgb;\n"
		"#endif // !AV_EMISSIVE_TEXTURE\n"
		"}\n"
		"{\n"
		"#ifdef AV_NORMAL_TEXTURE\n"
			"float L1 = dot(Normal,IN_Light1) * 0.5f + 0.5f;\n"
			"#define AV_LIGHT_1 IN_Light1\n"
		"#else\n"
			"float L1 = dot(Normal,afLightDir[1]) * 0.5f + 0.5f;\n"
			"#define AV_LIGHT_1 afLightDir[1]\n"
		"#endif\n"
			"float fHalfLambert = L1*L1;\n"
		"#ifdef AV_DIFFUSE_TEXTURE\n"
			"OUT.rgb += afLightColor[1].rgb * DIFFUSE_COLOR.rgb * tex2D(DIFFUSE_SAMPLER,IN.TexCoord0).rgb * fHalfLambert +\n"
		"#else\n"
			"OUT.rgb += afLightColor[1].rgb * DIFFUSE_COLOR.rgb * fHalfLambert +\n"
		"#endif // !AV_DIFFUSE_TEXTURE\n"

		"#ifdef AV_SPECULAR_COMPONENT\n"
			"#ifndef AV_SKYBOX_LOOKUP\n"
				"#ifdef AV_SPECULAR_TEXTURE\n"
					"SPECULAR_COLOR.rgb * afLightColor[1].rgb * tex2D(SPECULAR_SAMPLER,IN.TexCoord0).rgb * (saturate(fHalfLambert * 4.0f) * pow(dot(Reflect,AV_LIGHT_1),SPECULARITY)) + \n"
				"#else\n"
					"SPECULAR_COLOR.rgb * afLightColor[1].rgb * (saturate(fHalfLambert * 4.0f) * pow(dot(Reflect,AV_LIGHT_1),SPECULARITY)) + \n"
				"#endif // !AV_SPECULAR_TEXTURE\n"
			"#else\n"
				"#ifdef AV_SPECULAR_TEXTURE\n"
					"SPECULAR_COLOR.rgb * afLightColor[1].rgb * GetSSSCubeMap(Reflect) * tex2D(SPECULAR_SAMPLER,IN.TexCoord0).rgb * (saturate(fHalfLambert * 4.0f) * pow(dot(Reflect,AV_LIGHT_1),SPECULARITY)) + \n"
				"#else\n"
					"SPECULAR_COLOR.rgb * afLightColor[1].rgb * GetSSSCubeMap(Reflect) * (saturate(fHalfLambert * 4.0f) * pow(dot(Reflect,AV_LIGHT_1),SPECULARITY)) + \n"
				"#endif // !AV_SPECULAR_TEXTURE\n"
			"#endif // !AV_SKYBOX_LOOKUP\n"
		"#endif // !AV_SPECULAR_COMPONENT\n"
		"#ifdef AV_AMBIENT_TEXTURE\n"
			"AMBIENT_COLOR.rgb * afLightColorAmbient[1].rgb * tex2D(AMBIENT_SAMPLER,IN.TexCoord0).rgb + \n"
		"#else\n"
			"AMBIENT_COLOR.rgb * afLightColorAmbient[1].rgb + \n"
		"#endif // !AV_AMBIENT_TEXTURE\n"
		"#ifdef AV_EMISSIVE_TEXTURE\n"
			"EMISSIVE_COLOR.rgb * tex2D(EMISSIVE_SAMPLER,IN.TexCoord0).rgb;\n"
		"#else \n"
			"EMISSIVE_COLOR.rgb;\n"
		"#endif // !AV_EMISSIVE_TEXTURE\n"
		"}\n"
		"#ifdef AV_OPACITY\n"
		"OUT.a = TRANSPARENCY;\n"
		"#endif\n"
		"#ifdef AV_OPACITY_TEXTURE\n"
		"OUT.a *= tex2D(OPACITY_SAMPLER,IN.TexCoord0). AV_OPACITY_TEXTURE_REGISTER_MASK;\n"
		"#endif\n"
		"return OUT;\n"

		"#undef AV_LIGHT_0\n"
		"#undef AV_LIGHT_1\n"
		"}\n"
	// ----------------------------------------------------------------------------\n"
	"float4 MaterialPShaderSpecular_PS20_D1(VS_OUTPUT IN) : COLOR\n"
		"{\n"
		"float4 OUT = float4(0.0f,0.0f,0.0f,1.0f);\n"

		"#ifdef AV_NORMAL_TEXTURE\n"
		"float3 IN_Light0 = normalize(IN.Light0);\n"
		"float3 Normal  =  normalize(2.0f * tex2D(NORMAL_SAMPLER, IN.TexCoord0).rgb - 1.0f);\n"
		"#else\n"
		"float3 Normal = normalize(IN.Normal);\n"
		"#endif \n"
		"float3 ViewDir = normalize(IN.ViewDir);\n"

		"{\n"
		"#ifdef AV_NORMAL_TEXTURE\n"
		"float L1 = dot(Normal,IN_Light0) * 0.5f + 0.5f;\n"
		"float3 Reflect = reflect (Normal,IN_Light0);\n"
		"#else\n"
		"float L1 = dot(Normal,afLightDir[0]) * 0.5f + 0.5f;\n"
		"float3 Reflect = reflect (Normal,afLightDir[0]);\n"
		"#endif\n"
		"#ifdef AV_DIFFUSE_TEXTURE\n"
			"OUT.rgb += afLightColor[0].rgb * DIFFUSE_COLOR.rgb * tex2D(DIFFUSE_SAMPLER,IN.TexCoord0).rgb * L1 +\n"
		"#else\n"
			"OUT.rgb += afLightColor[0].rgb * DIFFUSE_COLOR.rgb * L1 +\n"
		"#endif // !AV_DIFFUSE_TEXTURE\n"

		"#ifdef AV_SPECULAR_COMPONENT\n"
		"#ifdef AV_SPECULAR_TEXTURE\n"
			"SPECULAR_COLOR.rgb * afLightColor[0].rgb * tex2D(SPECULAR_SAMPLER,IN.TexCoord0).rgb * (saturate(L1 * 4.0f) * pow(dot(Reflect,ViewDir),SPECULARITY)) + \n"
		"#else\n"
			"SPECULAR_COLOR.rgb * afLightColor[0].rgb * (saturate(L1 * 4.0f) * pow(dot(Reflect,ViewDir),SPECULARITY)) + \n"
		"#endif // !AV_SPECULAR_TEXTURE\n"
		"#endif // !AV_SPECULAR_COMPONENT\n"
		"#ifdef AV_AMBIENT_TEXTURE\n"
			"AMBIENT_COLOR.rgb * afLightColorAmbient[0].rgb * tex2D(AMBIENT_SAMPLER,IN.TexCoord0).rgb +\n"
		"#else\n"
			"AMBIENT_COLOR.rgb * afLightColorAmbient[0].rgb +\n"
		"#endif // !AV_AMBIENT_TEXTURE\n"
		"#ifdef AV_EMISSIVE_TEXTURE\n"
			"EMISSIVE_COLOR.rgb * tex2D(EMISSIVE_SAMPLER,IN.TexCoord0).rgb;\n"
		"#else \n"
			"EMISSIVE_COLOR.rgb;\n"
		"#endif // !AV_EMISSIVE_TEXTURE\n"
		"}\n"

		"#ifdef AV_OPACITY\n"
		"OUT.a = TRANSPARENCY;\n"
		"#endif\n"
		"#ifdef AV_OPACITY_TEXTURE\n"
		"OUT.a *= tex2D(OPACITY_SAMPLER,IN.TexCoord0). AV_OPACITY_TEXTURE_REGISTER_MASK;\n"
		"#endif\n"
		"return OUT;\n"
		"}\n"
	// ----------------------------------------------------------------------------\n"
	"float4 MaterialPShaderSpecular_PS20_D2(VS_OUTPUT IN) : COLOR\n"
		"{\n"
		"float4 OUT = float4(0.0f,0.0f,0.0f,1.0f);\n"

		"#ifdef AV_NORMAL_TEXTURE\n"
		"float3 IN_Light0 = normalize(IN.Light0);\n"
		"float3 IN_Light1 = normalize(IN.Light1);\n"
		"float3 Normal  =  normalize(2.0f * tex2D(NORMAL_SAMPLER, IN.TexCoord0) - 1.0f);\n"
		"#else\n"
		"float3 Normal = normalize(IN.Normal);\n"
		"#endif \n"
		"float3 ViewDir = normalize(IN.ViewDir);\n"

		"{\n"
		"#ifdef AV_NORMAL_TEXTURE\n"
		"float L1 = dot(Normal,IN_Light0) * 0.5f + 0.5f;\n"
		"float3 Reflect = reflect (Normal,IN_Light0);\n"
		"#else\n"
		"float L1 = dot(Normal,afLightDir[0]) * 0.5f + 0.5f;\n"
		"float3 Reflect = reflect (Normal,afLightDir[0]);\n"
		"#endif\n"
		"#ifdef AV_DIFFUSE_TEXTURE\n"
			"OUT.rgb += afLightColor[0].rgb * DIFFUSE_COLOR.rgb * tex2D(DIFFUSE_SAMPLER,IN.TexCoord0).rgb * L1 +\n"
		"#else\n"
			"OUT.rgb += afLightColor[0].rgb * DIFFUSE_COLOR.rgb * L1 +\n"
		"#endif // !AV_DIFFUSE_TEXTURE\n"

		"#ifdef AV_SPECULAR_COMPONENT\n"
		"#ifdef AV_SPECULAR_TEXTURE\n"
			"SPECULAR_COLOR.rgb * afLightColor[0].rgb * tex2D(SPECULAR_SAMPLER,IN.TexCoord0).rgb * (saturate(L1 * 4.0f) * pow(dot(Reflect,ViewDir),SPECULARITY)) + \n"
		"#else\n"
			"SPECULAR_COLOR.rgb * afLightColor[0].rgb * (saturate(L1 * 4.0f) * pow(dot(Reflect,ViewDir),SPECULARITY)) + \n"
		"#endif // !AV_SPECULAR_TEXTURE\n"
		"#endif // !AV_SPECULAR_COMPONENT\n"
		"#ifdef AV_AMBIENT_TEXTURE\n"
			"AMBIENT_COLOR.rgb * afLightColorAmbient[0].rgb * tex2D(AMBIENT_SAMPLER,IN.TexCoord0).rgb +\n"
		"#else\n"
			"AMBIENT_COLOR.rgb * afLightColorAmbient[0].rgb +\n"
		"#endif // !AV_AMBIENT_TEXTURE\n"
		"#ifdef AV_EMISSIVE_TEXTURE\n"
			"EMISSIVE_COLOR.rgb * tex2D(EMISSIVE_SAMPLER,IN.TexCoord0).rgb;\n"
		"#else \n"
			"EMISSIVE_COLOR.rgb;\n"
		"#endif // !AV_EMISSIVE_TEXTURE\n"
		"}\n"
		"{\n"
		"#ifdef AV_NORMAL_TEXTURE\n"
		"float L1 = dot(Normal,IN_Light1) * 0.5f + 0.5f;\n"
		"float3 Reflect = reflect (Normal,IN_Light1);\n"
		"#else\n"
		"float L1 = dot(Normal,afLightDir[1]) * 0.5f + 0.5f;\n"
		"float3 Reflect = reflect (Normal,afLightDir[1]);\n"
		"#endif\n"
		"#ifdef AV_DIFFUSE_TEXTURE\n"
			"OUT.rgb += afLightColor[1].rgb * DIFFUSE_COLOR.rgb * tex2D(DIFFUSE_SAMPLER,IN.TexCoord0).rgb * L1 +\n"
		"#else\n"
			"OUT.rgb += afLightColor[1].rgb * DIFFUSE_COLOR.rgb * L1 +\n"
		"#endif // !AV_DIFFUSE_TEXTURE\n"

		"#ifdef AV_SPECULAR_COMPONENT\n"
		"#ifdef AV_SPECULAR_TEXTURE\n"
			"SPECULAR_COLOR.rgb * afLightColor[1].rgb * tex2D(SPECULAR_SAMPLER,IN.TexCoord0).rgb * (saturate(L1 * 4.0f) * pow(dot(Reflect,ViewDir),SPECULARITY)) + \n"
		"#else\n"
			"SPECULAR_COLOR.rgb * afLightColor[1].rgb * (saturate(L1 * 4.0f) * pow(dot(Reflect,ViewDir),SPECULARITY)) + \n"
		"#endif // !AV_SPECULAR_TEXTURE\n"
		"#endif // !AV_SPECULAR_COMPONENT\n"
		"#ifdef AV_AMBIENT_TEXTURE\n"
			"AMBIENT_COLOR.rgb * afLightColorAmbient[1].rgb * tex2D(AMBIENT_SAMPLER,IN.TexCoord0).rgb +\n"
		"#else\n"
			"AMBIENT_COLOR.rgb * afLightColorAmbient[1].rgb + \n"
		"#endif // !AV_AMBIENT_TEXTURE\n"
		"#ifdef AV_EMISSIVE_TEXTURE\n"
			"EMISSIVE_COLOR.rgb * tex2D(EMISSIVE_SAMPLER,IN.TexCoord0).rgb;\n"
		"#else \n"
			"EMISSIVE_COLOR.rgb;\n"
		"#endif // !AV_EMISSIVE_TEXTURE\n"
		"}\n"

		"#ifdef AV_OPACITY\n"
		"OUT.a = TRANSPARENCY;\n"
		"#endif\n"
		"#ifdef AV_OPACITY_TEXTURE\n"
		"OUT.a *= tex2D(OPACITY_SAMPLER,IN.TexCoord0). AV_OPACITY_TEXTURE_REGISTER_MASK;\n"
		"#endif\n"
		"return OUT;\n"
		"}\n"


	// ----------------------------------------------------------------------------\n"
	// Technique for the material effect\n"
	// ----------------------------------------------------------------------------\n"
	"technique MaterialFXSpecular_D1\n"
		"{\n"
		"pass p0\n"
			"{\n"
			"CullMode=none;\n"

			"#ifdef AV_OPACITY_TEXTURE\n"
			"AlphaBlendEnable=TRUE;"
			"SrcBlend = srcalpha;\n"
			"DestBlend = invsrcalpha;\n"
			"#else\n"
			"#ifdef AV_OPACITY\n"
			"AlphaBlendEnable=TRUE;"
			"SrcBlend = srcalpha;\n"
			"DestBlend = invsrcalpha;\n"
			"#endif \n"
			"#endif\n"

			"PixelShader = compile ps_3_0 MaterialPShaderSpecular_D1();\n"
			"VertexShader = compile vs_3_0 MaterialVShader_D1();\n"
			"}\n"
		"};\n"
	"technique MaterialFXSpecular_D2\n"
		"{\n"
		"pass p0\n"
			"{\n"
			"CullMode=none;\n"

			"#ifdef AV_OPACITY_TEXTURE\n"
			"AlphaBlendEnable=TRUE;"
			"SrcBlend = srcalpha;\n"
			"DestBlend = invsrcalpha;\n"
			"#else\n"
			"#ifdef AV_OPACITY\n"
			"AlphaBlendEnable=TRUE;"
			"SrcBlend = srcalpha;\n"
			"DestBlend = invsrcalpha;\n"
			"#endif \n"
			"#endif\n"

			"PixelShader = compile ps_3_0 MaterialPShaderSpecular_D2();\n"
			"VertexShader = compile vs_3_0 MaterialVShader_D2();\n"
			"}\n"
		"};\n"


	// ----------------------------------------------------------------------------\n"
	// Technique for the material effect (ps_2_0)\n"
	// ----------------------------------------------------------------------------\n"
	"technique MaterialFXSpecular_PS20_D1\n"
		"{\n"
		"pass p0\n"
		"{\n"
		"CullMode=none;\n"

		"#ifdef AV_OPACITY_TEXTURE\n"
		"AlphaBlendEnable=TRUE;"
		"SrcBlend = srcalpha;\n"
		"DestBlend = invsrcalpha;\n"
		"#else\n"
		"#ifdef AV_OPACITY\n"
		"AlphaBlendEnable=TRUE;"
		"SrcBlend = srcalpha;\n"
		"DestBlend = invsrcalpha;\n"
		"#endif \n"
		"#endif\n"

		"PixelShader = compile ps_2_0 MaterialPShaderSpecular_PS20_D1();\n"
		"VertexShader = compile vs_2_0 MaterialVShader_D1();\n"
		"}\n"
		"};\n"
	"technique MaterialFXSpecular_PS20_D2\n"
		"{\n"
		"pass p0\n"
		"{\n"
		"CullMode=none;\n"

		"#ifdef AV_OPACITY_TEXTURE\n"
		"AlphaBlendEnable=TRUE;"
		"SrcBlend = srcalpha;\n"
		"DestBlend = invsrcalpha;\n"
		"#else\n"
		"#ifdef AV_OPACITY\n"
		"AlphaBlendEnable=TRUE;"
		"SrcBlend = srcalpha;\n"
		"DestBlend = invsrcalpha;\n"
		"#endif \n"
		"#endif\n"

		"PixelShader = compile ps_2_0 MaterialPShaderSpecular_PS20_D2();\n"
		"VertexShader = compile vs_2_0 MaterialVShader_D2();\n"
		"}\n"
		"};\n"
		);

std::string g_szPassThroughShader = std::string(
		//-------------------------------------------------------------------------------\n"
		/**\n"
		*	This program is distributed under the terms of the GNU Lesser General\n
		*	Public License (LGPL). \n
		*\n
		*	ASSIMP Viewer Utility\n
		*\n"
		*/
		//-------------------------------------------------------------------------------\n"

		"texture TEXTURE_2D;\n"
		"sampler TEXTURE_SAMPLER = sampler_state\n"
			"{\n"
			"Texture = (TEXTURE_2D);\n"
			"};\n"


		// ----------------------------------------------------------------------------\n"
		"struct VS_OUTPUT\n"
			"{\n"
			"// Position\n"
			"float4 _Position : POSITION;\n"

			"// Texture coordinate\n"
			"float2 _TexCoord0 : TEXCOORD0;\n"
			"};\n"


		// ----------------------------------------------------------------------------\n"
		"VS_OUTPUT DefaultVShader(float4 INPosition : POSITION,\n"
			"float2 INTexCoord0 : TEXCOORD0 )\n"
			"{\n"
			"// Initialize the output structure with zero\n"
			"VS_OUTPUT Out = (VS_OUTPUT)0;\n"

			"Out._Position = INPosition;\n"
			"Out._TexCoord0 = INTexCoord0;\n"

			"return Out;\n"
			"}\n"


		// ----------------------------------------------------------------------------\n"
		"float4 PassThrough_PS(float2 IN : TEXCOORD0) : COLOR\n"
		"{\n"
		"return tex2D(TEXTURE_SAMPLER,IN);\n"
		"}\n"
	

		// ----------------------------------------------------------------------------\n"
		// Simple pass-through technique\n"
		// ----------------------------------------------------------------------------\n"
		"technique PassThrough\n"
		"{\n"
		"pass p0\n"
		"{\n"
		"FillMode=Solid;\n"
		"ZEnable = FALSE;\n"
		"CullMode = none;\n"
		"AlphaBlendEnable = TRUE;\n"
		"SrcBlend =srcalpha;\n"
		"DestBlend =invsrcalpha;\n"
		"PixelShader = compile ps_2_0 PassThrough_PS();\n"
		"VertexShader = compile vs_2_0 DefaultVShader();\n"
		"}\n"
		"};\n"
		);
	};